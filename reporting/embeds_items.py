# --- START OF FILE reporting/embeds_items.py ---
import discord
import datetime
import math
import logging
import collections
import asyncio
from typing import List, Dict, Any, Optional, Union, Set

# S·ª≠ d·ª•ng import tuy·ªát ƒë·ªëi cho utils v√† config
import utils
import config
# Import helper ƒë·ªãnh d·∫°ng c√¢y t·ª´ embeds_user
from .embeds_user import _format_user_tree_line # <--- Import helper n√†y

log = logging.getLogger(__name__)

# --- Constants ---
TOP_INVITERS_LIMIT = 15 # Gi·∫£m gi·ªõi h·∫°n ƒë·ªÉ ph√π h·ª£p c√¢y
TOP_STICKER_USAGE_LIMIT = 15
UNUSED_EMOJI_LIMIT = 25 # Gi·ªõi h·∫°n hi·ªÉn th·ªã emoji kh√¥ng d√πng
LEAST_STICKER_USAGE_LIMIT = 15 # Gi·ªõi h·∫°n cho sticker √≠t d√πng

# --- Embed Functions ---

async def create_top_inviters_embed(
    invite_usage_counts: collections.Counter,
    guild: discord.Guild,
    bot: discord.Client
) -> Optional[discord.Embed]:
    """T·∫°o embed x·∫øp h·∫°ng ng∆∞·ªùi m·ªùi d·ª±a tr√™n t·ªïng s·ªë l∆∞·ª£t s·ª≠ d·ª•ng c√°c invite c·ªßa h·ªç (D·∫†NG C√ÇY)."""
    e = lambda name: utils.get_emoji(name, bot)
    title = f"{e('invite')} Top Ng∆∞·ªùi M·ªùi (L∆∞·ª£t s·ª≠ d·ª•ng)"
    limit = TOP_INVITERS_LIMIT
    filter_admins = False # Th∆∞·ªùng kh√¥ng l·ªçc admin cho BXH m·ªùi
    color=discord.Color.dark_teal()
    item_name_singular="l∆∞·ª£t d√πng"
    item_name_plural="l∆∞·ª£t d√πng"
    footer_note="D·ª±a tr√™n l∆∞·ª£t s·ª≠ d·ª•ng c√°c l·ªùi m·ªùi ƒëang ho·∫°t ƒë·ªông ƒë√£ qu√©t."

    if not invite_usage_counts:
        log.debug("B·ªè qua t·∫°o Top Ng∆∞·ªùi M·ªùi embed: Kh√¥ng c√≥ d·ªØ li·ªáu.")
        return None

    # L·ªçc bot (admin kh√¥ng l·ªçc theo filter_admins=False)
    filtered_sorted_users = [
        (uid, count) for uid, count in invite_usage_counts.most_common()
        if count > 0 and not getattr(guild.get_member(uid), 'bot', True)
    ]
    if not filtered_sorted_users:
        log.debug("B·ªè qua t·∫°o Top Ng∆∞·ªùi M·ªùi embed: Kh√¥ng c√≥ user h·ª£p l·ªá.")
        return None

    total_users_in_lb = len(filtered_sorted_users)
    users_to_display = filtered_sorted_users[:limit]
    user_ids_to_fetch = [uid for uid, count in users_to_display if isinstance(uid, int)]
    user_cache = await utils._fetch_user_dict(guild, user_ids_to_fetch, bot)

    title_emoji = e('award') if e('award') != '‚ùì' else 'üèÜ'
    embed = discord.Embed(title=f"{title_emoji} {title}", color=color)
    desc_prefix = "*ƒê√£ l·ªçc bot.*" # Kh√¥ng l·ªçc admin
    description_lines = [desc_prefix, ""]

    for rank, (user_id, count) in enumerate(users_to_display, 1):
        # Kh√¥ng c√≥ th√¥ng tin ph·ª• cho BXH n√†y
        lines = await _format_user_tree_line(
            rank, user_id, count, item_name_singular, item_name_plural,
            guild, user_cache, secondary_info=None
        )
        description_lines.extend(lines)

    if description_lines and description_lines[-1] == "": description_lines.pop()
    embed.description = "\n".join(description_lines)
    if len(embed.description) > 4096: embed.description = embed.description[:4090] + "\n[...]"

    footer_text = footer_note
    if total_users_in_lb > limit:
        footer_text = f"... v√† {total_users_in_lb - limit} ng∆∞·ªùi d√πng kh√°c. | {footer_note}"
    embed.set_footer(text=footer_text)

    return embed


async def create_top_sticker_usage_embed(
    sticker_counts: collections.Counter,
    bot: discord.Client,
    guild: discord.Guild,
    scan_data: Dict[str, Any],
    limit: int = TOP_STICKER_USAGE_LIMIT
) -> Optional[discord.Embed]:
    """T·∫°o embed hi·ªÉn th·ªã top stickers (server v√† m·∫∑c ƒë·ªãnh) ƒë∆∞·ª£c s·ª≠ d·ª•ng nhi·ªÅu nh·∫•t."""
    if not sticker_counts:
        log.debug("B·ªè qua t·∫°o Top Sticker Usage embed: Counter r·ªóng.")
        return None
    e = lambda name: utils.get_emoji(name, bot)
    server_sticker_ids: Set[int] = scan_data.get("server_sticker_ids_cache", set())

    title_emoji = e('award') if e('award') != '‚ùì' else 'üèÜ'
    title_item_emoji = e('sticker') if e('sticker') != '‚ùì' else '‚ú®'
    embed = discord.Embed(
        title=f"{title_emoji} {title_item_emoji} BXH Top {limit} Stickers ƒê∆∞·ª£c D√πng Nhi·ªÅu Nh·∫•t",
        color=discord.Color.dark_orange()
    )
    desc = "*D·ª±a tr√™n s·ªë l·∫ßn sticker ƒë∆∞·ª£c g·ª≠i.*"

    sorted_stickers = sticker_counts.most_common(limit)

    sticker_ids_to_fetch = [int(sid) for sid, count in sorted_stickers if sid.isdigit()]
    fetched_stickers_cache: Dict[int, Optional[discord.Sticker]] = {}
    if sticker_ids_to_fetch and bot:
        log.debug(f"Fetching {len(sticker_ids_to_fetch)} stickers for top usage embed...")
        async def fetch_sticker_safe(sticker_id):
            try: return await bot.fetch_sticker(sticker_id)
            except Exception: return None
        results = await asyncio.gather(*(fetch_sticker_safe(sid) for sid in sticker_ids_to_fetch))
        for sticker in results:
            if sticker: fetched_stickers_cache[sticker.id] = sticker
        log.debug(f"Fetch sticker ho√†n th√†nh cho top usage. Cache size: {len(fetched_stickers_cache)}")

    sticker_lines = []
    podium_emojis = ["ü•á", "ü•à", "ü•â"] # Th√™m podium cho sticker
    for rank, (sticker_id_str, count) in enumerate(sorted_stickers, 1):
        display_sticker = f"ID: `{sticker_id_str}`"
        sticker_obj: Optional[discord.Sticker] = None
        is_server_sticker = False
        sticker_name = "Unknown/Deleted"

        if sticker_id_str.isdigit():
            sticker_id = int(sticker_id_str)
            if sticker_id in server_sticker_ids: is_server_sticker = True
            sticker_obj = fetched_stickers_cache.get(sticker_id)
            if sticker_obj:
                sticker_name = utils.escape_markdown(sticker_obj.name)
                display_sticker = f"'{sticker_name}' (`{sticker_id_str}`)"
        elif not sticker_id_str.isdigit():
            display_sticker = "`ID kh√¥ng h·ª£p l·ªá?`"
            sticker_name = "Invalid ID"

        if is_server_sticker: display_sticker += f" {e('star')}"

        rank_prefix = podium_emojis[rank-1] if rank <= 3 else f"`#{rank:02d}`"
        sticker_lines.append(f"{rank_prefix} {display_sticker} ‚Äî **{count:,}** l·∫ßn")

    if not sticker_lines:
        log.debug("Kh√¥ng c√≥ d√≤ng sticker h·ª£p l·ªá n√†o ƒë·ªÉ hi·ªÉn th·ªã sau khi fetch/x·ª≠ l√Ω.")
        return None

    if len(sticker_counts) > limit:
        sticker_lines.append(f"\n... v√† {len(sticker_counts) - limit} sticker kh√°c.")

    embed.description = desc + "\n\n" + "\n".join(sticker_lines)
    if len(embed.description) > 4096:
        embed.description = embed.description[:4090] + "\n[...]"

    embed.set_footer(text=f"{e('star')} = Sticker c·ªßa Server n√†y.")
    return embed

# --- H√ÄM M·ªöI ---
async def create_least_sticker_usage_embed(
    sticker_counts: collections.Counter,
    bot: discord.Client,
    guild: discord.Guild,
    scan_data: Dict[str, Any],
    limit: int = LEAST_STICKER_USAGE_LIMIT
) -> Optional[discord.Embed]:
    """T·∫°o embed hi·ªÉn th·ªã top stickers √çT ƒë∆∞·ª£c s·ª≠ d·ª•ng nh·∫•t (c√≥ > 0 l∆∞·ª£t d√πng)."""
    if not sticker_counts:
        log.debug("B·ªè qua t·∫°o Least Sticker Usage embed: Counter r·ªóng.")
        return None
    e = lambda name: utils.get_emoji(name, bot)
    server_sticker_ids: Set[int] = scan_data.get("server_sticker_ids_cache", set())

    title_emoji = 'üìâ'
    title_item_emoji = e('sticker') if e('sticker') != '‚ùì' else '‚ú®'
    embed = discord.Embed(
        title=f"{title_emoji} {title_item_emoji} BXH Top {limit} Stickers √çt ƒê∆∞·ª£c S·ª≠ D·ª•ng Nh·∫•t",
        color=discord.Color.from_rgb(176, 196, 222) # Light Steel Blue
    )
    desc = "*D·ª±a tr√™n s·ªë l·∫ßn sticker ƒë∆∞·ª£c g·ª≠i. Ch·ªâ t√≠nh sticker c√≥ > 0 l∆∞·ª£t.*"

    # L·ªçc sticker c√≥ > 0 l∆∞·ª£t v√† s·∫Øp x·∫øp tƒÉng d·∫ßn
    filtered_stickers = {sid: count for sid, count in sticker_counts.items() if count > 0}
    if not filtered_stickers:
        embed.description = desc + "\n\n*Kh√¥ng c√≥ sticker n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng √≠t nh·∫•t 1 l·∫ßn.*"
        return embed

    sorted_stickers = sorted(filtered_stickers.items(), key=lambda item: item[1])[:limit]

    sticker_ids_to_fetch = [int(sid) for sid, count in sorted_stickers if sid.isdigit()]
    fetched_stickers_cache: Dict[int, Optional[discord.Sticker]] = {}
    if sticker_ids_to_fetch and bot:
        # (Logic fetch sticker gi·ªëng nh∆∞ h√†m top)
        log.debug(f"Fetching {len(sticker_ids_to_fetch)} stickers for least usage embed...")
        async def fetch_sticker_safe(sticker_id):
            try: return await bot.fetch_sticker(sticker_id)
            except Exception: return None
        results = await asyncio.gather(*(fetch_sticker_safe(sid) for sid in sticker_ids_to_fetch))
        for sticker in results:
            if sticker: fetched_stickers_cache[sticker.id] = sticker
        log.debug(f"Fetch sticker ho√†n th√†nh cho least usage. Cache size: {len(fetched_stickers_cache)}")

    sticker_lines = []
    for rank, (sticker_id_str, count) in enumerate(sorted_stickers, 1):
        display_sticker = f"ID: `{sticker_id_str}`"
        is_server_sticker = False
        sticker_name = "Unknown/Deleted"

        if sticker_id_str.isdigit():
            sticker_id = int(sticker_id_str)
            if sticker_id in server_sticker_ids: is_server_sticker = True
            sticker_obj = fetched_stickers_cache.get(sticker_id)
            if sticker_obj:
                sticker_name = utils.escape_markdown(sticker_obj.name)
                display_sticker = f"'{sticker_name}' (`{sticker_id_str}`)"
        elif not sticker_id_str.isdigit():
            display_sticker = "`ID kh√¥ng h·ª£p l·ªá?`"
            sticker_name = "Invalid ID"

        if is_server_sticker: display_sticker += f" {e('star')}"

        rank_prefix = f"`#{rank:02d}`"
        sticker_lines.append(f"{rank_prefix} {display_sticker} ‚Äî **{count:,}** l·∫ßn")

    if not sticker_lines:
        log.debug("Kh√¥ng c√≥ d√≤ng sticker h·ª£p l·ªá n√†o ƒë·ªÉ hi·ªÉn th·ªã (√≠t d√πng).")
        return None # Tr∆∞·ªùng h·ª£p hi·∫øm

    if len(filtered_stickers) > limit:
        sticker_lines.append(f"\n... v√† {len(filtered_stickers) - limit} sticker kh√°c (> 0 l∆∞·ª£t).")

    embed.description = desc + "\n\n" + "\n".join(sticker_lines)
    if len(embed.description) > 4096:
        embed.description = embed.description[:4090] + "\n[...]"

    embed.set_footer(text=f"{e('star')} = Sticker c·ªßa Server n√†y.")
    return embed

# --- H√ÄM M·ªöI ---
async def create_unused_emoji_embed(
    guild: discord.Guild,
    overall_custom_emoji_content_counts: collections.Counter,
    bot: discord.Client,
    limit: int = UNUSED_EMOJI_LIMIT
) -> Optional[discord.Embed]:
    """T·∫°o embed li·ªát k√™ c√°c emoji C·ª¶A SERVER kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong n·ªôi dung."""
    e = lambda name: utils.get_emoji(name, bot)
    server_emojis = guild.emojis
    if not server_emojis:
        log.debug("Server kh√¥ng c√≥ emoji n√†o ƒë·ªÉ ki·ªÉm tra unused.")
        return None

    used_ids = set(overall_custom_emoji_content_counts.keys())
    unused_emojis = [emoji for emoji in server_emojis if emoji.id not in used_ids]

    if not unused_emojis:
        embed = discord.Embed(
            title=f"{e('success')} Emoji Server ƒê·ªÅu ƒê∆∞·ª£c S·ª≠ D·ª•ng!",
            description="*T·∫•t c·∫£ emoji c·ªßa server n√†y ƒë·ªÅu ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng √≠t nh·∫•t 1 l·∫ßn trong n·ªôi dung tin nh·∫Øn.*",
            color=discord.Color.green()
        )
        return embed

    title_emoji = e('info') if e('info') != '‚ùì' else '‚ÑπÔ∏è'
    embed = discord.Embed(
        title=f"{title_emoji} Emoji Server Kh√¥ng ƒê∆∞·ª£c S·ª≠ D·ª•ng",
        description=f"*Danh s√°ch c√°c emoji c·ªßa server n√†y kh√¥ng xu·∫•t hi·ªán trong n·ªôi dung tin nh·∫Øn ƒë√£ qu√©t (t·ªëi ƒëa {limit}).*",
        color=discord.Color.blue()
    )

    unused_lines = [str(emoji) for emoji in unused_emojis[:limit]]
    embed.description += "\n\n" + " ".join(unused_lines)

    if len(unused_emojis) > limit:
        embed.set_footer(text=f"... v√† {len(unused_emojis) - limit} emoji kh√°c kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng.")

    return embed

# --- END OF FILE reporting/embeds_items.py ---